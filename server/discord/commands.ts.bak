import { Client, SlashCommandBuilder, EmbedBuilder, CommandInteraction, REST, Routes, Collection, Message, ButtonBuilder, ButtonStyle, ActionRowBuilder, ComponentType, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, PermissionFlagsBits, MessageFlags } from 'discord.js';
import { IStorage } from '../storage';
import { Item } from '@shared/schema';

// Discordå†…ã§ä½¿ç”¨ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã®ã‚«ãƒ¼ãƒˆã‚’ç®¡ç†
interface CartItem {
  itemId: number;
  name: string;
  price: number;
  quantity: number;
}

interface UserCart {
  userId: string;
  items: CartItem[];
  lastUpdated: Date;
}

// ãƒ¡ãƒ¢ãƒªå†…ã«ã‚«ãƒ¼ãƒˆæƒ…å ±ã‚’ä¿æŒï¼ˆå†èµ·å‹•ã§æ¶ˆå»ï¼‰
const userCarts = new Map<string, UserCart>();

// ã‚«ãƒ¼ãƒˆé–¢é€£ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
function getUserCart(userId: string): UserCart {
  if (!userCarts.has(userId)) {
    userCarts.set(userId, {
      userId,
      items: [],
      lastUpdated: new Date()
    });
  }
  return userCarts.get(userId)!;
}

function addToCart(userId: string, item: Item, quantity: number = 1): UserCart {
  const cart = getUserCart(userId);
  const existingItem = cart.items.find(i => i.itemId === item.id);
  
  if (existingItem) {
    existingItem.quantity += quantity;
  } else {
    cart.items.push({
      itemId: item.id,
      name: item.name,
      price: item.price,
      quantity: quantity
    });
  }
  
  cart.lastUpdated = new Date();
  return cart;
}

function removeFromCart(userId: string, itemId: number, quantity: number = 1): UserCart {
  const cart = getUserCart(userId);
  const existingItemIndex = cart.items.findIndex(i => i.itemId === itemId);
  
  if (existingItemIndex !== -1) {
    const item = cart.items[existingItemIndex];
    
    if (item.quantity <= quantity) {
      // æ•°é‡ãŒã‚¼ãƒ­ä»¥ä¸‹ã«ãªã‚‹å ´åˆã¯å•†å“è‡ªä½“ã‚’å‰Šé™¤
      cart.items.splice(existingItemIndex, 1);
    } else {
      // ãã†ã§ãªã„å ´åˆã¯æ•°é‡ã‚’æ¸›ã‚‰ã™
      item.quantity -= quantity;
    }
  }
  
  cart.lastUpdated = new Date();
  return cart;
}

function clearCart(userId: string): void {
  userCarts.delete(userId);
}

function getCartTotal(userId: string): number {
  const cart = getUserCart(userId);
  return cart.items.reduce((total, item) => total + (item.price * item.quantity), 0);
}

// Extend Discord.js Client to add commands property
interface BotClient extends Client {
  commands: Collection<string, any>;
}

// Handle message commands with ! prefix
export async function handleCommand(message: Message, commandName: string, args: string[], storage: IStorage) {
  try {
    // Map commandName to the appropriate command function
    switch(commandName) {
      case 'show':
        await handleShowCommand(message, storage);
        break;
      case 'buy':
        await handleBuyCommand(message, args, storage);
        break;
      case 'cart':
        await handleCartCommand(message, args, storage);
        break;
      case 'checkout':
        await handleCheckoutCommand(message, storage);
        break;
      case 'balance':
        await handleBalanceCommand(message, storage);
        break;
      case 'add':
        await handleAddCommand(message, args, storage);
        break;
      case 'remove':
        await handleRemoveCommand(message, args, storage);
        break;
      case 'price':
        await handlePriceCommand(message, args, storage);
        break;
      case 'stock':
        await handleStockCommand(message, args, storage);
        break;
      case 'help':
        await handleHelpCommand(message);
        break;
      case 'addcoins':
        await handleAddCoinsCommand(message, args, storage);
        break;
      default:
        await message.reply('ç„¡åŠ¹ãªã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ã¯ `!help` ã§ç¢ºèªã§ãã¾ã™ã€‚');
        break;
    }
  } catch (error) {
    console.error('Error handling command:', error);
    await message.reply('ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Show command for ! prefix
async function handleShowCommand(message: Message, storage: IStorage) {
  try {
    const items = await storage.getItems();
    const activeItems = items.filter(item => item.isActive);
    
    // Get bot settings or use defaults
    const guildSettings = await storage.getBotSettings(message.guildId || '');
    const currencyName = guildSettings?.currencyName || 'ã‚³ã‚¤ãƒ³';
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ®‹é«˜ã‚’å–å¾—
    const discordUser = await storage.getDiscordUserByDiscordId(message.author.id);
    const balance = discordUser ? discordUser.balance : 0;
    
    // Create embed for the vending machine
    const embed = new EmbedBuilder()
      .setTitle('ğŸ° ã˜ã¯ã‚“ã - å•†å“ä¸€è¦§')
      .setDescription('ä»¥ä¸‹ã®å•†å“ãŒè²©å£²ä¸­ã§ã™ã€‚ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è³¼å…¥ã§ãã¾ã™ã€‚')
      .setColor('#5865F2');

    // å•†å“ãŒãªã„å ´åˆ
    if (activeItems.length === 0) {
      embed.setDescription('ç¾åœ¨è²©å£²ä¸­ã®å•†å“ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
      return await message.reply({ embeds: [embed] });
    }
    
    // å•†å“ã”ã¨ã«ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ä½œæˆ
    const components: ActionRowBuilder<ButtonBuilder>[] = [];
    const PAGE_SIZE = 5; // 1ãƒšãƒ¼ã‚¸ã‚ãŸã‚Šã®å•†å“æ•°
    
    // ãƒšãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†ï¼ˆæœ€å¤§25å€‹ã®ãƒœã‚¿ãƒ³ã¾ã§è¡¨ç¤ºå¯èƒ½ãªã®ã§ã€5è¡ŒÃ—5åˆ—ã®å½¢å¼ï¼‰
    for (let i = 0; i < Math.min(activeItems.length, PAGE_SIZE); i++) {
      const item = activeItems[i];
      
      // å•†å“æƒ…å ±ã‚’Embedã«è¿½åŠ 
      const stockStatus = item.stock > 0 
        ? `åœ¨åº«: ${item.stock}`
        : 'åœ¨åº«åˆ‡ã‚Œ';
        
      embed.addFields({
        name: `#${item.id.toString().padStart(3, '0')} ${item.name}`,
        value: `${item.description}\nä¾¡æ ¼: **${item.price} ${currencyName}** | ${stockStatus}`,
        inline: false
      });
      
      // å•†å“ã®ãƒœã‚¿ãƒ³ã‚’ä½œæˆ
      const row = new ActionRowBuilder<ButtonBuilder>();
      
      // ç›´æ¥è³¼å…¥ãƒœã‚¿ãƒ³
      const buyButton = new ButtonBuilder()
        .setCustomId(`buy_${item.id}_1`) // ã‚¢ã‚¤ãƒ†ãƒ IDã¨æ•°é‡=1ã‚’å«ã‚ã‚‹
        .setLabel(`è³¼å…¥ã™ã‚‹ (${item.price} ${currencyName})`)
        .setStyle(ButtonStyle.Success)
        .setDisabled(item.stock <= 0 || balance < item.price);
      
      // ã‚«ãƒ¼ãƒˆã«è¿½åŠ ãƒœã‚¿ãƒ³
      const addToCartButton = new ButtonBuilder()
        .setCustomId(`cart_add_${item.id}_1`)
        .setLabel('ã‚«ãƒ¼ãƒˆã«è¿½åŠ ')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(item.stock <= 0);
      
      // è©³ç´°è¡¨ç¤ºãƒœã‚¿ãƒ³
      const detailsButton = new ButtonBuilder()
        .setCustomId(`details_${item.id}`)
        .setLabel('è©³ç´°')
        .setStyle(ButtonStyle.Secondary);
      
      row.addComponents(buyButton, addToCartButton, detailsButton);
      components.push(row);
    }
    
    // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
    if (activeItems.length > PAGE_SIZE) {
      const navRow = new ActionRowBuilder<ButtonBuilder>();
      
      const nextPageButton = new ButtonBuilder()
        .setCustomId('next_page')
        .setLabel('æ¬¡ã®ãƒšãƒ¼ã‚¸ â–¶')
        .setStyle(ButtonStyle.Secondary);
      
      const showAllButton = new ButtonBuilder()
        .setCustomId('show_all')
        .setLabel('ã™ã¹ã¦ã®å•†å“ã‚’è¦‹ã‚‹')
        .setStyle(ButtonStyle.Secondary);
      
      const cartButton = new ButtonBuilder()
        .setCustomId('view_cart')
        .setLabel('ã‚«ãƒ¼ãƒˆã‚’è¦‹ã‚‹')
        .setStyle(ButtonStyle.Secondary);
      
      navRow.addComponents(nextPageButton, showAllButton, cartButton);
      components.push(navRow);
    }
    
    // ãƒ•ãƒƒã‚¿ãƒ¼ã«æ®‹é«˜ã‚’è¡¨ç¤º
    if (discordUser) {
      embed.setFooter({ 
        text: `æ®‹é«˜: ${discordUser.balance} ${currencyName}` 
      });
    }
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    const sentMessage = await message.reply({ 
      embeds: [embed],
      components: components
    });
    
    // ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†ã™ã‚‹ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’è¨­å®š
    const collector = sentMessage.createMessageComponentCollector({ 
      time: 300000 // 5åˆ†é–“æœ‰åŠ¹
    });
    
    collector.on('collect', async (interaction) => {
      // ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸã®ãŒå…ƒã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
      if (interaction.user.id !== message.author.id) {
        return await interaction.reply({ 
          content: 'ã“ã®æ“ä½œã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡è€…ã®ã¿å®Ÿè¡Œã§ãã¾ã™ã€‚`!show`ã‚³ãƒãƒ³ãƒ‰ã§è‡ªåˆ†ã®ãƒªã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã¦ãã ã•ã„ã€‚', 
          flags: MessageFlags.Ephemeral
        });
      }
      
      const customId = interaction.customId;
      
      // ãƒœã‚¿ãƒ³ã®IDã‚’è§£æã—ã¦å‡¦ç†
      if (customId.startsWith('buy_')) {
        // ç›´æ¥è³¼å…¥å‡¦ç†
        const [_, itemId, quantity] = customId.split('_').map(Number);
        
        // è³¼å…¥ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        const item = activeItems.find(i => i.id === itemId);
        
        if (!item) {
          return await interaction.reply({
            content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
            ephemeral: true
          });
        }
        
        const confirmRow = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`confirm_buy_${itemId}_${quantity}`)
              .setLabel('è³¼å…¥ã™ã‚‹')
              .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
              .setCustomId('cancel_buy')
              .setLabel('ã‚­ãƒ£ãƒ³ã‚»ãƒ«')
              .setStyle(ButtonStyle.Secondary)
          );
        
        await interaction.reply({
          content: `${item.name} ã‚’ ${quantity} å€‹ã€åˆè¨ˆ ${item.price * quantity} ${currencyName} ã§è³¼å…¥ã—ã¾ã™ã‹ï¼Ÿ`,
          components: [confirmRow],
          flags: MessageFlags.Ephemeral
        });
      }
      else if (customId.startsWith('confirm_buy_')) {
        // è³¼å…¥ç¢ºèªå‡¦ç†
        const [_, __, itemId, quantity] = customId.split('_').map(Number);
        
        // æœ¬æ¥ã¯ã“ã“ã§ãƒãƒ³ãƒ‰ãƒ«ãƒã‚¤ã‚³ãƒãƒ³ãƒ‰ã‚’å‘¼ã¶ã¹ãã ãŒã€ã‚³ãƒ¼ãƒ‰é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ç›´æ¥å‡¦ç†
        try {
          const item = await storage.getItem(itemId);
          if (!item || !item.isActive || (!item.infiniteStock && item.stock < quantity)) {
            return await interaction.update({
              content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
              components: []
            });
          }
          
          const discordUser = await storage.getDiscordUserByDiscordId(interaction.user.id);
          if (!discordUser) {
            return await interaction.update({
              content: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
              components: []
            });
          }
          
          const totalPrice = item.price * quantity;
          
          if (discordUser.balance < totalPrice) {
            return await interaction.update({
              content: `æ®‹é«˜ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å¿…è¦: ${totalPrice} ${currencyName}ã€æ®‹é«˜: ${discordUser.balance} ${currencyName}`,
              components: []
            });
          }
          
          // è³¼å…¥å‡¦ç†å®Ÿè¡Œ
          await storage.updateDiscordUserBalance(discordUser.id, -totalPrice);
          // ç„¡é™åœ¨åº«ã§ãªã‘ã‚Œã°åœ¨åº«ã‚’æ¸›ã‚‰ã™
          if (!item.infiniteStock) {
            await storage.updateItem(item.id, { stock: item.stock - quantity });
          }
          
          // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³è¨˜éŒ²
          await storage.createTransaction({
            discordUserId: discordUser.id,
            itemId: item.id,
            quantity: quantity,
            totalPrice: totalPrice
          });
          
          // ãƒ­ãƒ¼ãƒ«ä»˜ä¸ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
          if (item.discordRoleId && message.guild) {
            try {
              const member = await message.guild.members.fetch(interaction.user.id);
              await member.roles.add(item.discordRoleId);
            } catch (roleError) {
              console.error('Error adding role:', roleError);
            }
          }
          
          // æ›´æ–°ã•ã‚ŒãŸæ®‹é«˜ã‚’å–å¾—
          const updatedUser = await storage.getDiscordUser(discordUser.id);
          const newBalance = updatedUser ? updatedUser.balance : 0;
          
          await interaction.update({
            content: `âœ… ${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼\næ®‹é«˜: ${newBalance} ${currencyName}`,
            components: []
          });
          
          // å…¬é–‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
          const publicEmbed = new EmbedBuilder()
            .setTitle('ğŸ›’ å•†å“ãŒè³¼å…¥ã•ã‚Œã¾ã—ãŸï¼')
            .setDescription(`${interaction.user.username} ãŒ ${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼`)
            .setColor('#3BA55C')
            .setTimestamp();
            
          await message.channel.send({ embeds: [publicEmbed] });
          
          // ã‚¢ã‚¤ãƒ†ãƒ ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹å ´åˆã¯DMã§é€ä¿¡
          if (item.content) {
            try {
              // Discord.js v14ã§ã¯ç›´æ¥DMã‚’é€ä¿¡ã§ãã‚‹
              await interaction.user.send({
                content: `ğŸ å•†å“ã®è©³ç´°æƒ…å ±: ${item.name}\n\n${item.content}`
              });
            } catch (dmError) {
              console.error('Error sending DM:', dmError);
              // DMãŒé€ã‚Œãªã„å ´åˆã¯ã‚¨ãƒ•ã‚§ãƒ¡ãƒ©ãƒ«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§é€šçŸ¥
              await interaction.followUp({
                content: 'DMãŒé€ä¿¡ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
                flags: MessageFlags.Ephemeral
              });
            }
          }
        } catch (error) {
          console.error('Error processing buy:', error);
          await interaction.update({
            content: 'è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
            components: []
          });
        }
      }
      else if (customId === 'cancel_buy') {
        // è³¼å…¥ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        await interaction.update({
          content: 'è³¼å…¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚',
          components: []
        });
      }
      else if (customId.startsWith('cart_add_')) {
        // ã‚«ãƒ¼ãƒˆã«è¿½åŠ 
        const [_, __, itemId, quantity] = customId.split('_').map(Number);
        
        try {
          const item = await storage.getItem(itemId);
          if (!item || !item.isActive || item.stock < quantity) {
            return await interaction.reply({
              content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ã€åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
              ephemeral: true
            });
          }
          
          // ã‚«ãƒ¼ãƒˆã«è¿½åŠ 
          addToCart(interaction.user.id, item, quantity);
          
          await interaction.reply({
            content: `${item.name} ã‚’ ${quantity} å€‹ã‚«ãƒ¼ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸï¼\nç¢ºèªã™ã‚‹ã«ã¯ \`!cart\` ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`,
            ephemeral: true
          });
        } catch (error) {
          console.error('Error adding to cart:', error);
          await interaction.reply({
            content: 'ã‚«ãƒ¼ãƒˆã«è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
            ephemeral: true
          });
        }
      }
      else if (customId.startsWith('details_')) {
        // å•†å“è©³ç´°è¡¨ç¤º
        const itemId = Number(customId.split('_')[1]);
        const item = await storage.getItem(itemId);
        
        if (!item) {
          return await interaction.reply({
            content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
            ephemeral: true
          });
        }
        
        const detailsEmbed = new EmbedBuilder()
          .setTitle(`å•†å“è©³ç´°: ${item.name}`)
          .setDescription(item.description)
          .addFields(
            { name: 'ä¾¡æ ¼', value: `${item.price} ${currencyName}`, inline: true },
            { name: 'åœ¨åº«', value: `${item.stock}`, inline: true },
            { name: 'å•†å“ID', value: `${item.id}`, inline: true }
          )
          .setColor('#5865F2')
          .setFooter({ text: `!buy ${item.id} [æ•°é‡] ã§è³¼å…¥ã€!cart add ${item.id} [æ•°é‡] ã§ã‚«ãƒ¼ãƒˆã«è¿½åŠ ã§ãã¾ã™` });
        
        // æ•°é‡é¸æŠç”¨ã‚»ãƒ¬ã‚¯ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
        const quantityRow = new ActionRowBuilder<StringSelectMenuBuilder>()
          .addComponents(
            new StringSelectMenuBuilder()
              .setCustomId(`quantity_select_${itemId}`)
              .setPlaceholder('è³¼å…¥æ•°é‡ã‚’é¸æŠ')
              .addOptions(
                new StringSelectMenuOptionBuilder().setLabel('1å€‹').setValue(`1_${itemId}`),
                new StringSelectMenuOptionBuilder().setLabel('2å€‹').setValue(`2_${itemId}`),
                new StringSelectMenuOptionBuilder().setLabel('3å€‹').setValue(`3_${itemId}`),
                new StringSelectMenuOptionBuilder().setLabel('5å€‹').setValue(`5_${itemId}`),
                new StringSelectMenuOptionBuilder().setLabel('10å€‹').setValue(`10_${itemId}`)
              )
          );
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³
        const actionRow = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`direct_buy_${itemId}_1`)
              .setLabel(`ä»Šã™ãè³¼å…¥`)
              .setStyle(ButtonStyle.Success)
              .setDisabled(item.stock <= 0 || balance < item.price),
            new ButtonBuilder()
              .setCustomId(`cart_add_${itemId}_1`)
              .setLabel('ã‚«ãƒ¼ãƒˆã«è¿½åŠ ')
              .setStyle(ButtonStyle.Primary)
              .setDisabled(item.stock <= 0)
          );
        
        await interaction.reply({
          embeds: [detailsEmbed],
          components: [quantityRow, actionRow],
          ephemeral: true
        });
      }
      else if (customId === 'view_cart') {
        // ã‚«ãƒ¼ãƒˆã‚’è¡¨ç¤º
        await interaction.deferUpdate();
        await handleCartCommand(message, [], storage);
      }
      else if (customId === 'next_page' || customId === 'show_all') {
        // æ¬¡ãƒšãƒ¼ã‚¸ã¾ãŸã¯å…¨è¡¨ç¤º
        // å®Ÿè£…ã¯è¤‡é›‘ã«ãªã‚‹ãŸã‚ã€ç°¡æ˜“è¡¨ç¤ºã«æˆ»ã™
        await interaction.update({
          content: 'è¿½åŠ ã®å•†å“ã‚„ã™ã¹ã¦ã®å•†å“ã‚’è¦‹ã‚‹ã«ã¯ `!show all` ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚',
          components: []
        });
      }
      else if (customId.startsWith('quantity_select_')) {
        // æ•°é‡é¸æŠå‡¦ç†
        const selectValues = interaction.values[0].split('_');
        const quantity = Number(selectValues[0]);
        const itemId = Number(selectValues[1]);
        
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.update({
            content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
            components: []
          });
        }
        
        // æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’ç”Ÿæˆ
        const newRow = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`direct_buy_${itemId}_${quantity}`)
              .setLabel(`${quantity}å€‹è³¼å…¥ (${item.price * quantity} ${currencyName})`)
              .setStyle(ButtonStyle.Success)
              .setDisabled(item.stock < quantity || balance < (item.price * quantity)),
            new ButtonBuilder()
              .setCustomId(`cart_add_${itemId}_${quantity}`)
              .setLabel(`${quantity}å€‹ã‚«ãƒ¼ãƒˆã«è¿½åŠ `)
              .setStyle(ButtonStyle.Primary)
              .setDisabled(item.stock < quantity)
          );
        
        await interaction.update({
          content: `${item.name} ã‚’ ${quantity} å€‹é¸æŠã—ã¾ã—ãŸã€‚`,
          components: [newRow]
        });
      }
      else if (customId.startsWith('direct_buy_')) {
        // è©³ç´°ç”»é¢ã‹ã‚‰ã®ç›´æ¥è³¼å…¥
        const [_, __, itemId, quantity] = customId.split('_').map(Number);
        
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.update({
            content: 'å•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
            components: []
          });
        }
        
        const confirmRow = new ActionRowBuilder<ButtonBuilder>()
          .addComponents(
            new ButtonBuilder()
              .setCustomId(`confirm_buy_${itemId}_${quantity}`)
              .setLabel('è³¼å…¥ã™ã‚‹')
              .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
              .setCustomId('cancel_buy')
              .setLabel('ã‚­ãƒ£ãƒ³ã‚»ãƒ«')
              .setStyle(ButtonStyle.Secondary)
          );
        
        await interaction.update({
          content: `${item.name} ã‚’ ${quantity} å€‹ã€åˆè¨ˆ ${item.price * quantity} ${currencyName} ã§è³¼å…¥ã—ã¾ã™ã‹ï¼Ÿ`,
          components: [confirmRow]
        });
      }
    });
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®å‡¦ç†
    collector.on('end', async collected => {
      if (sentMessage.editable) {
        try {
          await sentMessage.edit({
            content: `è¡¨ç¤ºãŒæœ‰åŠ¹æœŸé™åˆ‡ã‚Œã«ãªã‚Šã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦å•†å“ã‚’è¡¨ç¤ºã™ã‚‹ã«ã¯ \`!show\` ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`,
            components: []
          });
        } catch (error) {
          console.error('Error updating expired message:', error);
        }
      }
    });
  } catch (error) {
    console.error('Error in show command:', error);
    await message.reply('å•†å“ãƒªã‚¹ãƒˆã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Buy command for ! prefix
async function handleBuyCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
    if (args.length === 0 || args[0] === 'help') {
      return await message.reply('ä½¿ç”¨æ–¹æ³•: `!buy [å•†å“ID] [æ•°é‡(çœç•¥å¯)]`\nä¾‹: `!buy 1 2` - ID:1ã®å•†å“ã‚’2å€‹è³¼å…¥\nè¤‡æ•°å•†å“ã®è³¼å…¥ã«ã¯ `!cart` ã¨ `!checkout` ã‚³ãƒãƒ³ãƒ‰ãŒä¾¿åˆ©ã§ã™ã€‚');
    }
    
    // Get item ID and quantity from arguments
    const itemId = parseInt(args[0]);
    const quantity = args.length > 1 ? parseInt(args[1]) : 1;
    
    if (isNaN(itemId) || isNaN(quantity) || quantity < 1) {
      return await message.reply('æœ‰åŠ¹ãªå•†å“IDã¨æ•°é‡ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹: `!buy 1 2`');
    }
    
    // Get the item
    const item = await storage.getItem(itemId);
    if (!item) {
      return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    if (!item.isActive) {
      return await message.reply('ã“ã®å•†å“ã¯ç¾åœ¨è²©å£²åœæ­¢ä¸­ã§ã™ã€‚');
    }
    
    if (item.stock < quantity) {
      return await message.reply(`åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®åœ¨åº«: ${item.stock}`);
    }
    
    // é¸æŠã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨è³¼å…¥ç¢ºèªãƒœã‚¿ãƒ³ã‚’æº–å‚™
    const totalPrice = item.price * quantity;
    let selectedOption: string | null = null;
    
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å†…å®¹ã‚’æº–å‚™
    let contentText = `${item.name} ã‚’ ${quantity} å€‹ã€åˆè¨ˆ ${totalPrice} ã‚³ã‚¤ãƒ³ã§è³¼å…¥ã—ã¾ã™ã‹ï¼Ÿ`;
    
    // ç¢ºèªãƒœã‚¿ãƒ³ã®æº–å‚™
    const confirmButton = new ButtonBuilder()
      .setCustomId('confirm_purchase')
      .setLabel('è³¼å…¥ã™ã‚‹')
      .setStyle(ButtonStyle.Success);
      
    const cancelButton = new ButtonBuilder()
      .setCustomId('cancel_purchase')
      .setLabel('ã‚­ãƒ£ãƒ³ã‚»ãƒ«')
      .setStyle(ButtonStyle.Secondary);
    
    const confirmRow = new ActionRowBuilder<ButtonBuilder>().addComponents(confirmButton, cancelButton);
    
    // é¸æŠè‚¢ãŒã‚ã‚‹å ´åˆã¯é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¿½åŠ 
    const components: any[] = [confirmRow];
    
    if (item.options && item.options.length > 0) {
      contentText += '\n\n**é¸æŠè‚¢ã‹ã‚‰1ã¤é¸ã‚“ã§ãã ã•ã„**:';
      
      // é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ä½œæˆ
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('option_select')
        .setPlaceholder('é¸æŠè‚¢ã‚’é¸ã‚“ã§ãã ã•ã„')
        .addOptions(
          item.options.map(option => ({
            label: option,
            value: option
          }))
        );
      
      const selectRow = new ActionRowBuilder<any>().addComponents(selectMenu);
      components.unshift(selectRow); // é¸æŠè‚¢ã‚’å…ˆã«è¡¨ç¤º
    }
    
    // ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
    const confirmMessage = await message.reply({
      content: contentText,
      components: components
    });
    
    // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆ
    const filter = (i: { user: { id: string; }; }) => i.user.id === message.author.id;
    const collector = confirmMessage.createMessageComponentCollector({ 
      filter, 
      time: 60000, // 60ç§’é–“æœ‰åŠ¹
    });
    
    // Handle interactions (both buttons and select menu)
    collector.on('collect', async (interaction) => {
      try {
        console.log(`Interaction received: ${interaction.customId}`);
        
        // Handle select menu interaction
        if (interaction.customId === 'option_select' && interaction.isStringSelectMenu()) {
          selectedOption = interaction.values[0];
          await interaction.update({
            content: `${contentText}\n\né¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³: **${selectedOption}**`,
            components: components
          });
          return;
        }
        
        // Handle purchase confirmation
        if (interaction.customId === 'confirm_purchase') {
          console.log('Processing purchase confirmation');
          
          // Check if option is selected when required
          if (item.options && item.options.length > 0 && !selectedOption) {
            await interaction.update({
              content: `${contentText}\n\nâš ï¸ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`,
              components: components
            });
            return;
          }
          
          // Get user info
          const discordUser = await storage.getDiscordUserByDiscordId(message.author.id);
          if (!discordUser) {
            await interaction.update({
              content: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚',
              components: []
            });
            return;
          }
          
          // Verify item stock
          const updatedItem = await storage.getItem(itemId);
          if (!updatedItem || (!updatedItem.infiniteStock && updatedItem.stock < quantity)) {
            await interaction.update({
              content: 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚åœ¨åº«çŠ¶æ³ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚',
              components: []
            });
            return;
          }
          
          // Check balance
          if (discordUser.balance < totalPrice) {
            await interaction.update({
              content: `æ®‹é«˜ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å¿…è¦ãªé‡‘é¡: ${totalPrice} ã‚³ã‚¤ãƒ³ã€ç¾åœ¨ã®æ®‹é«˜: ${discordUser.balance} ã‚³ã‚¤ãƒ³`,
              components: []
            });
            return;
          }
          
          try {
            // Update balance and stock
            await storage.updateDiscordUserBalance(discordUser.id, -totalPrice);
            
            if (!updatedItem.infiniteStock) {
              await storage.updateItem(updatedItem.id, { 
                stock: updatedItem.stock - quantity 
              });
            }
            
            // Record transaction
            await storage.createTransaction({
              discordUserId: discordUser.id,
              itemId: updatedItem.id,
              quantity: quantity,
              totalPrice: totalPrice
            });
            
            // Assign role if applicable
            if (updatedItem.discordRoleId && message.guild) {
              try {
                const member = await message.guild.members.fetch(message.author.id);
                await member.roles.add(updatedItem.discordRoleId);
              } catch (roleError) {
                console.error('Error adding role:', roleError);
              }
            }
            
            // Get updated balance
            const updatedUser = await storage.getDiscordUser(discordUser.id);
            const newBalance = updatedUser ? updatedUser.balance : 0;
            
            // Create success message
            let successMessage = `âœ… ${updatedItem.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼\næ®‹é«˜: ${newBalance} ã‚³ã‚¤ãƒ³`;
            
            if (selectedOption) {
              successMessage += `\n\né¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³: **${selectedOption}**`;
            }
            
            if (updatedItem.content) {
              successMessage += `\n\nğŸ“© å•†å“ã®è©³ç´°ã¯DMã‚’ã”ç¢ºèªãã ã•ã„ã€‚`;
            }
            
            // Update interaction
            await interaction.update({
              content: successMessage,
              components: []
            });
            
            // Send DM if item has content
            if (updatedItem.content) {
              try {
                const dmChannel = await message.author.createDM();
                let dmContent = `**${updatedItem.name}** ã®è³¼å…¥ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼\n\n`;
                
                if (selectedOption) {
                  dmContent += `é¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³: **${selectedOption}**\n\n`;
                }
                
                dmContent += `ã“ã“ã«è³¼å…¥ã—ãŸå•†å“ã®å†…å®¹ã‚’è¨˜è¼‰ã—ã¾ã™:\n\n${updatedItem.content}`;
                
                await dmChannel.send({
                  content: dmContent
                });
              } catch (dmError) {
                console.error("Failed to send DM:", dmError);
              }
            }
            
            // Send public announcement
            const publicEmbed = new EmbedBuilder()
              .setTitle('ğŸ›’ å•†å“ãŒè³¼å…¥ã•ã‚Œã¾ã—ãŸï¼')
              .setDescription(`${message.author.username} ãŒ ${updatedItem.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼`)
              .setColor('#3BA55C')
              .setTimestamp();
              
            await message.channel.send({ embeds: [publicEmbed] });
          } catch (purchaseError) {
            console.error('Error processing purchase:', purchaseError);
            await interaction.update({
              content: 'è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
              components: []
            });
          }
        } else if (interaction.customId === 'cancel_purchase') {
          await interaction.update({
            content: 'è³¼å…¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚',
            components: []
          });
        }
      } catch (error) {
        console.error('Error handling interaction:', error);
        try {
          await interaction.update({
            content: 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
            components: []
          });
        } catch (followupError) {
          console.error('Error sending error message:', followupError);
        }
      }
    });
    
    // Handle timeout
    collector.on('end', async (collected) => {
      if (collected.size === 0) {
        await confirmMessage.edit({
          content: 'æ™‚é–“åˆ‡ã‚Œã§ã™ã€‚è³¼å…¥ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚',
          components: []
        });
      }
    });
  } catch (error) {
    console.error('Error in buy command:', error);
    await message.reply('è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Cart command for ! prefix
async function handleCartCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
    if (args.length > 0 && args[0] === 'help') {
      return await message.reply(
        'ä½¿ç”¨æ–¹æ³•:\n' +
        '`!cart` - ã‚«ãƒ¼ãƒˆã®å†…å®¹ã‚’è¡¨ç¤º\n' +
        '`!cart add [å•†å“ID] [æ•°é‡(çœç•¥å¯)]` - ã‚«ãƒ¼ãƒˆã«å•†å“ã‚’è¿½åŠ \n' +
        '`!cart remove [å•†å“ID] [æ•°é‡(çœç•¥å¯)]` - ã‚«ãƒ¼ãƒˆã‹ã‚‰å•†å“ã‚’å‰Šé™¤\n' +
        '`!cart clear` - ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã™ã‚‹'
      );
    }
    
    const subCommand = args.length > 0 ? args[0].toLowerCase() : 'show';
    
    // ã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ã«åŸºã¥ã„ã¦å‡¦ç†
    switch (subCommand) {
      case 'show':
        // ã‚«ãƒ¼ãƒˆã®å†…å®¹ã‚’è¡¨ç¤º
        const cart = getUserCart(message.author.id);
        
        if (cart.items.length === 0) {
          return await message.reply('ã‚«ãƒ¼ãƒˆã¯ç©ºã§ã™ã€‚`!show` ã§å•†å“ä¸€è¦§ã‚’ç¢ºèªã—ã€`!cart add [å•†å“ID] [æ•°é‡]` ã§ã‚«ãƒ¼ãƒˆã«è¿½åŠ ã§ãã¾ã™ã€‚');
        }
        
        // ã‚«ãƒ¼ãƒˆå†…å®¹ã‚’Embedã§è¡¨ç¤º
        const cartEmbed = new EmbedBuilder()
          .setTitle('ğŸ›’ ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°ã‚«ãƒ¼ãƒˆ')
          .setDescription(`${message.author.username} ã•ã‚“ã®ã‚«ãƒ¼ãƒˆå†…å®¹:`)
          .setColor('#5865F2');
          
        let total = 0;
        cart.items.forEach(item => {
          const itemTotal = item.price * item.quantity;
          total += itemTotal;
          cartEmbed.addFields({
            name: `${item.name} (ID: ${item.itemId})`,
            value: `${item.quantity} å€‹ Ã— ${item.price} ã‚³ã‚¤ãƒ³ = ${itemTotal} ã‚³ã‚¤ãƒ³`
          });
        });
        
        cartEmbed.addFields({
          name: 'åˆè¨ˆ',
          value: `${total} ã‚³ã‚¤ãƒ³`
        });
        
        cartEmbed.setFooter({
          text: 'è³¼å…¥ã™ã‚‹ã«ã¯ !checkout ã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„'
        });
        
        // ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        const checkoutButton = new ButtonBuilder()
          .setCustomId('checkout')
          .setLabel('è³¼å…¥æ‰‹ç¶šãã¸')
          .setStyle(ButtonStyle.Success);
          
        const clearButton = new ButtonBuilder()
          .setCustomId('clear_cart')
          .setLabel('ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã™ã‚‹')
          .setStyle(ButtonStyle.Danger);
          
        const row = new ActionRowBuilder<ButtonBuilder>().addComponents(checkoutButton, clearButton);
        
        const cartMessage = await message.reply({
          embeds: [cartEmbed],
          components: [row]
        });
        
        // ãƒœã‚¿ãƒ³ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆ
        const filter = (i: { user: { id: string; }; }) => i.user.id === message.author.id;
        const collector = cartMessage.createMessageComponentCollector({ 
          filter, 
          time: 60000, // 60ç§’é–“æœ‰åŠ¹
          componentType: ComponentType.Button
        });
        
        collector.on('collect', async (interaction) => {
          if (interaction.customId === 'checkout') {
            await interaction.update({
              components: []
            });
            
            // ãƒã‚§ãƒƒã‚¯ã‚¢ã‚¦ãƒˆå‡¦ç†ã‚’å®Ÿè¡Œ
            await handleCheckoutCommand(message, storage);
          } else if (interaction.customId === 'clear_cart') {
            clearCart(message.author.id);
            await interaction.update({
              content: 'ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã—ã¾ã—ãŸã€‚',
              embeds: [],
              components: []
            });
          }
        });
        
        break;
        
      case 'add':
        // ã‚«ãƒ¼ãƒˆã«å•†å“ã‚’è¿½åŠ 
        if (args.length < 2) {
          return await message.reply('ä½¿ç”¨æ–¹æ³•: `!cart add [å•†å“ID] [æ•°é‡(çœç•¥å¯)]`');
        }
        
        const addItemId = parseInt(args[1]);
        const addQuantity = args.length > 2 ? parseInt(args[2]) : 1;
        
        if (isNaN(addItemId) || isNaN(addQuantity) || addQuantity < 1) {
          return await message.reply('æœ‰åŠ¹ãªå•†å“IDã¨æ•°é‡ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
        }
        
        // å•†å“æƒ…å ±ã‚’å–å¾—
        const itemToAdd = await storage.getItem(addItemId);
        if (!itemToAdd) {
          return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        if (!itemToAdd.isActive) {
          return await message.reply('ã“ã®å•†å“ã¯ç¾åœ¨è²©å£²åœæ­¢ä¸­ã§ã™ã€‚');
        }
        
        // ç„¡é™åœ¨åº«ã§ãªã‘ã‚Œã°åœ¨åº«ãƒã‚§ãƒƒã‚¯
        if (!itemToAdd.infiniteStock && itemToAdd.stock < addQuantity) {
          return await message.reply(`åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®åœ¨åº«: ${itemToAdd.stock}`);
        }
        
        // ã‚«ãƒ¼ãƒˆã«è¿½åŠ 
        addToCart(message.author.id, itemToAdd, addQuantity);
        
        await message.reply(`${itemToAdd.name} ã‚’ ${addQuantity} å€‹ã‚«ãƒ¼ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸï¼ã‚«ãƒ¼ãƒˆã‚’ç¢ºèªã™ã‚‹ã«ã¯ \`!cart\` ã¨å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚`);
        break;
        
      case 'remove':
        // ã‚«ãƒ¼ãƒˆã‹ã‚‰å•†å“ã‚’å‰Šé™¤
        if (args.length < 2) {
          return await message.reply('ä½¿ç”¨æ–¹æ³•: `!cart remove [å•†å“ID] [æ•°é‡(çœç•¥å¯)]`');
        }
        
        const removeItemId = parseInt(args[1]);
        const removeQuantity = args.length > 2 ? parseInt(args[2]) : 1;
        
        if (isNaN(removeItemId) || isNaN(removeQuantity) || removeQuantity < 1) {
          return await message.reply('æœ‰åŠ¹ãªå•†å“IDã¨æ•°é‡ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
        }
        
        // ã‚«ãƒ¼ãƒˆã‹ã‚‰å‰Šé™¤
        const userCart = getUserCart(message.author.id);
        const itemInCart = userCart.items.find(item => item.itemId === removeItemId);
        
        if (!itemInCart) {
          return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ã¯ã‚«ãƒ¼ãƒˆã«å…¥ã£ã¦ã„ã¾ã›ã‚“ã€‚');
        }
        
        removeFromCart(message.author.id, removeItemId, removeQuantity);
        
        await message.reply(`${itemInCart.name} ã‚’ ${Math.min(removeQuantity, itemInCart.quantity)} å€‹ã‚«ãƒ¼ãƒˆã‹ã‚‰å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
        break;
        
      case 'clear':
        // ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã™ã‚‹
        clearCart(message.author.id);
        await message.reply('ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã—ã¾ã—ãŸã€‚');
        break;
        
      default:
        await message.reply('ç„¡åŠ¹ãªã‚µãƒ–ã‚³ãƒãƒ³ãƒ‰ã§ã™ã€‚`!cart help` ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚');
        break;
    }
  } catch (error) {
    console.error('Error in cart command:', error);
    await message.reply('ã‚«ãƒ¼ãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Checkout command for ! prefix
async function handleCheckoutCommand(message: Message, storage: IStorage) {
  try {
    // ã‚«ãƒ¼ãƒˆã®å†…å®¹ã‚’å–å¾—
    const cart = getUserCart(message.author.id);
    
    if (cart.items.length === 0) {
      return await message.reply('ã‚«ãƒ¼ãƒˆã¯ç©ºã§ã™ã€‚`!show` ã§å•†å“ä¸€è¦§ã‚’ç¢ºèªã—ã€`!cart add [å•†å“ID] [æ•°é‡]` ã§ã‚«ãƒ¼ãƒˆã«è¿½åŠ ã§ãã¾ã™ã€‚');
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
    let discordUser = await storage.getDiscordUserByDiscordId(message.author.id);
    
    if (!discordUser) {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
      discordUser = await storage.createDiscordUser({
        discordId: message.author.id,
        username: message.author.username,
        balance: 1000 // åˆæœŸæ®‹é«˜
      });
    }
    
    // åˆè¨ˆé‡‘é¡ã‚’è¨ˆç®—
    const total = getCartTotal(message.author.id);
    
    // æ®‹é«˜ãƒã‚§ãƒƒã‚¯
    if (discordUser.balance < total) {
      return await message.reply(`æ®‹é«˜ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å¿…è¦ãªé‡‘é¡: ${total} ã‚³ã‚¤ãƒ³ã€ç¾åœ¨ã®æ®‹é«˜: ${discordUser.balance} ã‚³ã‚¤ãƒ³`);
    }
    
    // åœ¨åº«ãƒã‚§ãƒƒã‚¯
    let stockError = false;
    const stockChecks = await Promise.all(cart.items.map(async (item) => {
      const dbItem = await storage.getItem(item.itemId);
      // ç„¡é™åœ¨åº«ã‚¢ã‚¤ãƒ†ãƒ ã§ãªãã€ã‹ã¤åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆ
      if (!dbItem || (!dbItem.infiniteStock && dbItem.stock < item.quantity)) {
        stockError = true;
        return `${item.name}: åœ¨åº«ä¸è¶³ï¼ˆè¦æ±‚: ${item.quantity}ã€åœ¨åº«: ${dbItem ? dbItem.stock : 0}ï¼‰`;
      }
      return null;
    }));
    
    if (stockError) {
      const errorItems = stockChecks.filter(Boolean).join('\n');
      return await message.reply(`æ¬¡ã®å•†å“ã§åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™:\n${errorItems}`);
    }
    
    // ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
    const confirmEmbed = new EmbedBuilder()
      .setTitle('ğŸ›’ è³¼å…¥ç¢ºèª')
      .setDescription('ä»¥ä¸‹ã®å†…å®¹ã§è³¼å…¥ã‚’ç¢ºå®šã—ã¾ã™ã‹ï¼Ÿ')
      .setColor('#5865F2');
      
    cart.items.forEach(item => {
      const itemTotal = item.price * item.quantity;
      confirmEmbed.addFields({
        name: `${item.name}`,
        value: `${item.quantity} å€‹ Ã— ${item.price} ã‚³ã‚¤ãƒ³ = ${itemTotal} ã‚³ã‚¤ãƒ³`
      });
    });
    
    confirmEmbed.addFields(
      { name: 'åˆè¨ˆé‡‘é¡', value: `${total} ã‚³ã‚¤ãƒ³` },
      { name: 'è³¼å…¥å¾Œæ®‹é«˜', value: `${discordUser.balance - total} ã‚³ã‚¤ãƒ³` }
    );
    
    // ç¢ºèªãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
    const confirmButton = new ButtonBuilder()
      .setCustomId('confirm_checkout')
      .setLabel('è³¼å…¥ç¢ºå®š')
      .setStyle(ButtonStyle.Success);
      
    const cancelButton = new ButtonBuilder()
      .setCustomId('cancel_checkout')
      .setLabel('ã‚­ãƒ£ãƒ³ã‚»ãƒ«')
      .setStyle(ButtonStyle.Secondary);
    
    const row = new ActionRowBuilder<ButtonBuilder>().addComponents(confirmButton, cancelButton);
    
    const confirmMessage = await message.reply({
      embeds: [confirmEmbed],
      components: [row]
    });
    
    // ãƒœã‚¿ãƒ³ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆ
    const filter = (i: { user: { id: string; }; }) => i.user.id === message.author.id;
    const collector = confirmMessage.createMessageComponentCollector({ 
      filter, 
      time: 60000, // 60ç§’é–“æœ‰åŠ¹
      componentType: ComponentType.Button
    });
    
    collector.on('collect', async (interaction) => {
      if (interaction.customId === 'confirm_checkout') {
        try {
          // å†åº¦ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã¨åœ¨åº«ã‚’ç¢ºèª
          const updatedUser = await storage.getDiscordUserByDiscordId(message.author.id);
          if (!updatedUser || updatedUser.balance < total) {
            await interaction.update({
              content: 'æ®‹é«˜ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚',
              embeds: [],
              components: []
            });
            return;
          }
          
          // åœ¨åº«ã‚’å†ãƒã‚§ãƒƒã‚¯
          let stockErrorFound = false;
          for (const item of cart.items) {
            const dbItem = await storage.getItem(item.itemId);
            if (!dbItem || (!dbItem.infiniteStock && dbItem.stock < item.quantity)) {
              stockErrorFound = true;
              break;
            }
          }
          
          if (stockErrorFound) {
            await interaction.update({
              content: 'ç”³ã—è¨³ã‚ã‚Šã¾ã›ã‚“ã€‚åœ¨åº«çŠ¶æ³ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚',
              embeds: [],
              components: []
            });
            return;
          }
          
          // è³¼å…¥å‡¦ç†ã‚’å®Ÿè¡Œ
          // 1. æ®‹é«˜ã‚’æ¸›ã‚‰ã™
          await storage.updateDiscordUserBalance(updatedUser.id, -total);
          
          // 2. å„å•†å“ã®å‡¦ç†
          const transactions = [];
          for (const item of cart.items) {
            // åœ¨åº«ã‚’æ¸›ã‚‰ã™ï¼ˆç„¡é™åœ¨åº«ã§ãªã„å ´åˆã®ã¿ï¼‰
            const dbItem = await storage.getItem(item.itemId);
            if (dbItem) {
              if (!dbItem.infiniteStock) {
                await storage.updateItem(dbItem.id, { stock: dbItem.stock - item.quantity });
              }
              
              // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³è¨˜éŒ²ã‚’ä½œæˆ
              const transaction = await storage.createTransaction({
                discordUserId: updatedUser.id,
                itemId: dbItem.id,
                quantity: item.quantity,
                totalPrice: item.price * item.quantity
              });
              
              transactions.push(transaction);
              
              // ãƒ­ãƒ¼ãƒ«ã‚’ä»˜ä¸ï¼ˆè©²å½“ã™ã‚‹å ´åˆï¼‰
              if (dbItem.discordRoleId && message.guild) {
                try {
                  const member = await message.guild.members.fetch(message.author.id);
                  await member.roles.add(dbItem.discordRoleId);
                } catch (roleError) {
                  console.error('Error adding role:', roleError);
                  // ãƒ­ãƒ¼ãƒ«ä»˜ä¸ã«å¤±æ•—ã—ã¦ã‚‚è³¼å…¥å‡¦ç†ã¯ç¶šè¡Œ
                }
              }
            }
          }
          
          // æ›´æ–°ã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
          const finalUser = await storage.getDiscordUser(updatedUser.id);
          
          // ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã™ã‚‹
          clearCart(message.author.id);
          
          // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
          const successEmbed = new EmbedBuilder()
            .setTitle('âœ… è³¼å…¥å®Œäº†')
            .setDescription('ä»¥ä¸‹ã®å•†å“ã®è³¼å…¥ãŒå®Œäº†ã—ã¾ã—ãŸï¼')
            .setColor('#3BA55C')
            .setTimestamp();
            
          cart.items.forEach(item => {
            successEmbed.addFields({
              name: item.name,
              value: `${item.quantity} å€‹`
            });
          });
          
          successEmbed.addFields({
            name: 'åˆè¨ˆé‡‘é¡',
            value: `${total} ã‚³ã‚¤ãƒ³`
          });
          
          if (finalUser) {
            successEmbed.addFields({
              name: 'æ®‹é«˜',
              value: `${finalUser.balance} ã‚³ã‚¤ãƒ³`
            });
          }
          
          await interaction.update({
            embeds: [successEmbed],
            components: []
          });
          
          // DMã§è³¼å…¥ã—ãŸå•†å“ã®è©³ç´°ã‚’é€ä¿¡
          try {
            const dmEmbed = new EmbedBuilder()
              .setTitle('ğŸ‰ è³¼å…¥å®Œäº†ã®ãŠçŸ¥ã‚‰ã›')
              .setDescription('ã”è³¼å…¥ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚ä»¥ä¸‹ãŒè³¼å…¥å†…å®¹ã§ã™ã€‚')
              .setColor('#3BA55C')
              .setTimestamp();
            
            // å„å•†å“ã®è©³ç´°æƒ…å ±ã‚’DMã«å«ã‚ã‚‹
            for (const cartItem of cart.items) {
              const dbItem = await storage.getItem(cartItem.itemId);
              if (dbItem) {
                dmEmbed.addFields({
                  name: `${dbItem.name} (${cartItem.quantity}å€‹)`,
                  value: dbItem.content || dbItem.description || 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã¯ã‚ã‚Šã¾ã›ã‚“'
                });
              }
            }
            
            await message.author.send({ embeds: [dmEmbed] });
          } catch (dmError) {
            console.error('Error sending DM:', dmError);
            // DMãŒé€ä¿¡ã§ããªã„å ´åˆã¯ãƒãƒ£ãƒ³ãƒãƒ«ã§é€šçŸ¥
            await message.channel.send({ 
              content: `${message.author}ã•ã‚“ã€DMãŒé€ä¿¡ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚` 
            });
          }
          
          // è³¼å…¥é€šçŸ¥ã‚’é€ä¿¡ï¼ˆå…¬é–‹ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰
          const publicEmbed = new EmbedBuilder()
            .setTitle('ğŸ›ï¸ å•†å“ãŒè³¼å…¥ã•ã‚Œã¾ã—ãŸï¼')
            .setDescription(`${message.author.username} ãŒ ${cart.items.length} ç¨®é¡ã®å•†å“ã‚’è³¼å…¥ã—ã¾ã—ãŸï¼è©³ç´°ã¯DMã§é€ä¿¡ã•ã‚Œã¾ã—ãŸã€‚`)
            .setColor('#3BA55C')
            .setTimestamp();
            
          await message.channel.send({ embeds: [publicEmbed] });
        } catch (error) {
          console.error('Error processing checkout:', error);
          await interaction.update({
            content: 'è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
            embeds: [],
            components: []
          });
        }
      } else if (interaction.customId === 'cancel_checkout') {
        await interaction.update({
          content: 'è³¼å…¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸã€‚',
          embeds: [],
          components: []
        });
      }
    });
    
    // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†
    collector.on('end', async (collected) => {
      if (collected.size === 0) {
        await confirmMessage.edit({
          content: 'æ™‚é–“åˆ‡ã‚Œã§ã™ã€‚è³¼å…¥ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚',
          embeds: [],
          components: []
        });
      }
    });
  } catch (error) {
    console.error('Error in checkout command:', error);
    await message.reply('è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Help command for ! prefix
async function handleHelpCommand(message: Message) {
  try {
    const helpEmbed = new EmbedBuilder()
      .setTitle('ã˜ã¯ã‚“ãbot ãƒ˜ãƒ«ãƒ—')
      .setDescription('åˆ©ç”¨å¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰ä¸€è¦§')
      .setColor('#5865F2')
      .addFields(
        { name: '!show', value: 'è²©å£²ä¸­ã®å•†å“ä¸€è¦§ã‚’è¡¨ç¤ºã—ã¾ã™' },
        { name: '!buy [å•†å“ID] [æ•°é‡]', value: 'æŒ‡å®šã—ãŸå•†å“ã‚’ç›´æ¥è³¼å…¥ã—ã¾ã™' },
        { name: '!cart', value: 'ç¾åœ¨ã®ã‚«ãƒ¼ãƒˆå†…å®¹ã‚’è¡¨ç¤ºã—ã¾ã™' },
        { name: '!cart add [å•†å“ID] [æ•°é‡]', value: 'ã‚«ãƒ¼ãƒˆã«å•†å“ã‚’è¿½åŠ ã—ã¾ã™' },
        { name: '!cart remove [å•†å“ID] [æ•°é‡]', value: 'ã‚«ãƒ¼ãƒˆã‹ã‚‰å•†å“ã‚’å‰Šé™¤ã—ã¾ã™' },
        { name: '!cart clear', value: 'ã‚«ãƒ¼ãƒˆã‚’ç©ºã«ã—ã¾ã™' },
        { name: '!checkout', value: 'ã‚«ãƒ¼ãƒˆå†…ã®å•†å“ã‚’è³¼å…¥ã—ã¾ã™' },
        { name: '!balance', value: 'ç¾åœ¨ã®æ®‹é«˜ã‚’ç¢ºèªã—ã¾ã™' },
        { name: '!help', value: 'ã“ã®ãƒ˜ãƒ«ãƒ—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¾ã™' }
      )
      .setFooter({ text: 'ã˜ã¯ã‚“ãbot by Replit' });
      
    // ç®¡ç†è€…å‘ã‘ã‚³ãƒãƒ³ãƒ‰ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡è€…ãŒç®¡ç†è€…æ¨©é™ã‚’æŒã£ã¦ã„ã‚‹å ´åˆã®ã¿è¡¨ç¤º
    if (message.member && message.member.permissions.has('Administrator')) {
      helpEmbed.addFields(
        { 
          name: 'ç®¡ç†è€…ã‚³ãƒãƒ³ãƒ‰', 
          value: 'ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™'
        },
        { name: '!add [åå‰] [èª¬æ˜] [ä¾¡æ ¼] [åœ¨åº«]', value: 'æ–°ã—ã„å•†å“ã‚’è¿½åŠ ã—ã¾ã™' },
        { name: '!price [å•†å“ID] [æ–°ä¾¡æ ¼]', value: 'å•†å“ã®ä¾¡æ ¼ã‚’å¤‰æ›´ã—ã¾ã™' },
        { name: '!stock [å•†å“ID] [æ•°é‡]', value: 'å•†å“ã®åœ¨åº«ã‚’è¿½åŠ ã—ã¾ã™' },
        { name: '!remove [å•†å“ID]', value: 'å•†å“ã‚’å‰Šé™¤ã—ã¾ã™' },
        { name: '!addcoins @username [ã‚³ã‚¤ãƒ³æ•°]', value: 'ç‰¹å®šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚³ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¾ã™' }
      );
    }
    
    await message.reply({ embeds: [helpEmbed] });
  } catch (error) {
    console.error('Error in help command:', error);
    await message.reply('ãƒ˜ãƒ«ãƒ—è¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Balance command for ! prefix
async function handleBalanceCommand(message: Message, storage: IStorage) {
  try {
    // Get the user
    const discordUser = await storage.getDiscordUserByDiscordId(message.author.id);
    if (!discordUser) {
      return await message.reply('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    // Get bot settings or use defaults
    const guildSettings = await storage.getBotSettings(message.guildId || '');
    const currencyName = guildSettings?.currencyName || 'ã‚³ã‚¤ãƒ³';
    
    // Send balance message
    await message.reply(`ç¾åœ¨ã®æ®‹é«˜: ${discordUser.balance} ${currencyName}`);
  } catch (error) {
    console.error('Error in balance command:', error);
    await message.reply('æ®‹é«˜ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Add command for ! prefix
async function handleAddCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // Check if user has admin permissions
    if (!message.member?.permissions.has('Administrator')) {
      return await message.reply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
    }
    
    // Example format: !add "Item Name" 500 "Item Description" 10 role_id
    // We need to parse more complex arguments with quotes
    const fullText = args.join(' ');
    const nameMatch = fullText.match(/"([^"]+)"/);
    
    if (!nameMatch) {
      return await message.reply('å•†å“åã‚’å¼•ç”¨ç¬¦ã§å›²ã‚“ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹: `!add "ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ­ãƒ¼ãƒ«" 500 "èª¬æ˜æ–‡" 10`');
    }
    
    const name = nameMatch[1];
    const remainingText = fullText.replace(nameMatch[0], '').trim();
    const parts = remainingText.split(' ');
    
    const price = parseInt(parts[0]);
    if (isNaN(price) || price < 0) {
      return await message.reply('æœ‰åŠ¹ãªä¾¡æ ¼ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
    }
    
    const descMatch = remainingText.match(/"([^"]+)"/);
    if (!descMatch) {
      return await message.reply('èª¬æ˜æ–‡ã‚’å¼•ç”¨ç¬¦ã§å›²ã‚“ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹: `!add "ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ãƒ­ãƒ¼ãƒ«" 500 "èª¬æ˜æ–‡" 10`');
    }
    
    const description = descMatch[1];
    const afterDesc = remainingText.replace(descMatch[0], '').trim().split(' ');
    
    const stock = parseInt(afterDesc[1]) || 0;
    const roleId = afterDesc[2] || null;
    
    // Create the item
    const item = await storage.createItem({
      name,
      description,
      price,
      stock,
      isActive: true,
      discordRoleId: roleId
    });
    
    await message.reply(`å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼š${item.name} (ID: ${item.id}, ä¾¡æ ¼: ${item.price} ã‚³ã‚¤ãƒ³)`);
  } catch (error) {
    console.error('Error in add command:', error);
    await message.reply('å•†å“ã®è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Remove command for ! prefix
async function handleRemoveCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // Check if user has admin permissions
    if (!message.member?.permissions.has('Administrator')) {
      return await message.reply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
    }
    
    const itemId = parseInt(args[0]);
    if (isNaN(itemId)) {
      return await message.reply('æœ‰åŠ¹ãªå•†å“IDã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
    }
    
    // Get the item first to check if it exists
    const item = await storage.getItem(itemId);
    if (!item) {
      return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    // Delete the item
    await storage.deleteItem(itemId);
    
    await message.reply(`å•†å“ã‚’å‰Šé™¤ã—ã¾ã—ãŸï¼š${item.name} (ID: ${item.id})`);
  } catch (error) {
    console.error('Error in remove command:', error);
    await message.reply('å•†å“ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Price command for ! prefix
async function handlePriceCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // Check if user has admin permissions
    if (!message.member?.permissions.has('Administrator')) {
      return await message.reply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
    }
    
    const itemId = parseInt(args[0]);
    const newPrice = parseInt(args[1]);
    
    if (isNaN(itemId) || isNaN(newPrice)) {
      return await message.reply('æœ‰åŠ¹ãªå•†å“IDã¨ä¾¡æ ¼ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹: `!price 1 500`');
    }
    
    if (newPrice < 0) {
      return await message.reply('ä¾¡æ ¼ã¯0ä»¥ä¸Šã®å€¤ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
    }
    
    // Get the item first to check if it exists
    const item = await storage.getItem(itemId);
    if (!item) {
      return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    // Update the item price
    const updatedItem = await storage.updateItem(itemId, { price: newPrice });
    
    await message.reply(`å•†å“ã®ä¾¡æ ¼ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼š${updatedItem?.name} (æ–°ä¾¡æ ¼: ${newPrice} ã‚³ã‚¤ãƒ³)`);
  } catch (error) {
    console.error('Error in price command:', error);
    await message.reply('ä¾¡æ ¼ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Stock command for ! prefix
async function handleStockCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // Check if user has admin permissions
    if (!message.member?.permissions.has('Administrator')) {
      return await message.reply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
    }
    
    const itemId = parseInt(args[0]);
    const quantity = parseInt(args[1]);
    
    if (isNaN(itemId) || isNaN(quantity)) {
      return await message.reply('æœ‰åŠ¹ãªå•†å“IDã¨åœ¨åº«æ•°ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚ä¾‹: `!stock 1 10`');
    }
    
    if (quantity < 0) {
      return await message.reply('åœ¨åº«æ•°ã¯0ä»¥ä¸Šã®å€¤ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
    }
    
    // Get the item first to check if it exists
    const item = await storage.getItem(itemId);
    if (!item) {
      return await message.reply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    // Update the item stock
    const updatedItem = await storage.updateItem(itemId, { stock: quantity });
    
    await message.reply(`å•†å“ã®åœ¨åº«æ•°ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼š${updatedItem?.name} (æ–°åœ¨åº«æ•°: ${quantity})`);
  } catch (error) {
    console.error('Error in stock command:', error);
    await message.reply('åœ¨åº«æ•°ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// Register all commands with the Discord client
// ã‚³ã‚¤ãƒ³è¿½åŠ ã‚³ãƒãƒ³ãƒ‰ for ! prefix
async function handleAddCoinsCommand(message: Message, args: string[], storage: IStorage) {
  try {
    // ç®¡ç†è€…æ¨©é™ãƒã‚§ãƒƒã‚¯
    if (!message.member?.permissions.has('Administrator')) {
      return await message.reply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
    }
    
    // å¼•æ•°ãƒã‚§ãƒƒã‚¯: !addcoins @username 500
    if (args.length < 2) {
      return await message.reply('ä½¿ç”¨æ–¹æ³•: `!addcoins @username [ã‚³ã‚¤ãƒ³æ•°]`');
    }
    
    const userMention = args[0];
    const amount = parseInt(args[1]);
    
    if (isNaN(amount) || amount <= 0) {
      return await message.reply('ã‚³ã‚¤ãƒ³æ•°ã¯æ­£ã®æ•´æ•°ã§æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
    }
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‹ã‚‰ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã‚’æŠ½å‡º
    let userId = userMention;
    if (userMention.startsWith('<@') && userMention.endsWith('>')) {
      userId = userMention.slice(2, -1);
      if (userId.startsWith('!')) {
        userId = userId.slice(1);
      }
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    let discordUser = await storage.getDiscordUserByDiscordId(userId);
    
    if (!discordUser) {
      const mentionedUser = await message.client.users.fetch(userId).catch(() => null);
      if (!mentionedUser) {
        return await message.reply('æŒ‡å®šã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
      }
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
      discordUser = await storage.createDiscordUser({
        discordId: userId,
        username: mentionedUser.username,
        balance: 0
      });
    }
    
    // æ®‹é«˜æ›´æ–°
    const updatedUser = await storage.updateDiscordUserBalance(discordUser.id, amount);
    
    await message.reply(`${userMention} ã« ${amount} ã‚³ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚æ–°ã—ã„æ®‹é«˜: ${updatedUser?.balance} ã‚³ã‚¤ãƒ³`);
  } catch (error) {
    console.error('Error adding coins:', error);
    await message.reply('ã‚³ã‚¤ãƒ³è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
  }
}

// ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ã‚³ã‚¤ãƒ³è¿½åŠ ã‚³ãƒãƒ³ãƒ‰
const addCoinsCommand = {
  data: new SlashCommandBuilder()
    .setName('vending_addcoins')
    .setDescription('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚³ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¾ã™')
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addUserOption(option => 
      option.setName('user')
        .setDescription('ã‚³ã‚¤ãƒ³ã‚’è¿½åŠ ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼')
        .setRequired(true))
    .addIntegerOption(option => 
      option.setName('amount')
        .setDescription('è¿½åŠ ã™ã‚‹ã‚³ã‚¤ãƒ³æ•°ï¼ˆæ­£ã®æ•´æ•°ï¼‰')
        .setMinValue(1)
        .setRequired(true)),
  async execute(interaction: CommandInteraction, storage: IStorage) {
    await interaction.deferReply({ ephemeral: true });
    
    try {
      const options = interaction.options;
      const user = options.getUser('user');
      const amount = options.getInteger('amount');
      
      if (!user || !amount) {
        return await interaction.editReply('ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã‚³ã‚¤ãƒ³æ•°ãŒå¿…è¦ã§ã™ã€‚');
      }
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼å­˜åœ¨ãƒã‚§ãƒƒã‚¯
      let discordUser = await storage.getDiscordUserByDiscordId(user.id);
      
      if (!discordUser) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
        discordUser = await storage.createDiscordUser({
          discordId: user.id,
          username: user.username,
          balance: 0
        });
      }
      
      // æ®‹é«˜æ›´æ–°
      const updatedUser = await storage.updateDiscordUserBalance(discordUser.id, amount);
      
      await interaction.editReply(`${user.toString()} ã« ${amount} ã‚³ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚æ–°ã—ã„æ®‹é«˜: ${updatedUser?.balance} ã‚³ã‚¤ãƒ³`);
    } catch (error) {
      console.error('Error adding coins:', error);
      await interaction.editReply('ã‚³ã‚¤ãƒ³è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    }
  }
};

export async function registerCommands(client: BotClient) {
  // Show command - displays all items in the vending machine
  const showCommand = {
    data: new SlashCommandBuilder()
      .setName('show')
      .setDescription('è²©å£²ä¸­ã®å•†å“ãƒªã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã¾ã™'),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply();
      
      try {
        const items = await storage.getItems();
        const activeItems = items.filter(item => item.isActive);
        
        // Get bot settings or use defaults
        const guildSettings = await storage.getBotSettings(interaction.guildId || '');
        const currencyName = guildSettings?.currencyName || 'ã‚³ã‚¤ãƒ³';
        
        // Create embed for the vending machine
        const embed = new EmbedBuilder()
          .setTitle('è‡ªå‹•è²©å£²æ©Ÿ')
          .setDescription(`ä»¥ä¸‹ã®å•†å“ãŒè²©å£²ä¸­ã§ã™ï¼è³¼å…¥ã™ã‚‹ã«ã¯ \`!buy [å•†å“ID]\` ã¾ãŸã¯ \`!cart add [å•†å“ID]\` ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„`)
          .setColor('#5865F2');
          
        // Add fields for each item
        activeItems.forEach(item => {
          const stockStatus = item.stock > 0 
            ? `åœ¨åº«: ${item.stock}`
            : 'åœ¨åº«åˆ‡ã‚Œ';
            
          embed.addFields({
            name: `#${item.id.toString().padStart(3, '0')} ${item.name}`,
            value: `${item.description}\nä¾¡æ ¼: **${item.price} ${currencyName}** | ${stockStatus}`,
            inline: false
          });
        });
        
        // Get user balance
        const discordUser = await storage.getDiscordUserByDiscordId(interaction.user.id);
        if (discordUser) {
          embed.setFooter({ 
            text: `æ®‹é«˜: ${discordUser.balance} ${currencyName}` 
          });
        }
        
        await interaction.editReply({ embeds: [embed] });
      } catch (error) {
        console.error('Error in show command:', error);
        await interaction.editReply('å•†å“ãƒªã‚¹ãƒˆã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Buy command - purchases an item from the vending machine
  const buyCommand = {
    data: new SlashCommandBuilder()
      .setName('buy')
      .setDescription('æŒ‡å®šã—ãŸå•†å“ã‚’è³¼å…¥ã—ã¾ã™')
      .addIntegerOption(option => 
        option.setName('item_id')
          .setDescription('è³¼å…¥ã™ã‚‹å•†å“ã®ID')
          .setRequired(true))
      .addIntegerOption(option => 
        option.setName('quantity')
          .setDescription('è³¼å…¥ã™ã‚‹æ•°é‡')
          .setRequired(false)),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      try {
        // Get item ID and quantity from options
        const itemId = interaction.options.getInteger('item_id');
        const quantity = interaction.options.getInteger('quantity') || 1;
        
        if (!itemId || quantity < 1) {
          return await interaction.editReply('æœ‰åŠ¹ãªå•†å“IDã¨æ•°é‡ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
        }
        
        // Get the item
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.editReply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        if (!item.isActive) {
          return await interaction.editReply('ã“ã®å•†å“ã¯ç¾åœ¨è²©å£²åœæ­¢ä¸­ã§ã™ã€‚');
        }
        
        // ç„¡é™åœ¨åº«ã§ãªã‘ã‚Œã°åœ¨åº«ãƒã‚§ãƒƒã‚¯
        if (!item.infiniteStock && item.stock < quantity) {
          return await interaction.editReply(`åœ¨åº«ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚ç¾åœ¨ã®åœ¨åº«: ${item.stock}`);
        }
        
        // Get the user
        const discordUser = await storage.getDiscordUserByDiscordId(interaction.user.id);
        if (!discordUser) {
          return await interaction.editReply('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        // Calculate total price
        const totalPrice = item.price * quantity;
        
        // Check if user has enough balance
        if (discordUser.balance < totalPrice) {
          return await interaction.editReply(`æ®‹é«˜ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚å¿…è¦ãªé‡‘é¡: ${totalPrice} ã‚³ã‚¤ãƒ³ã€ç¾åœ¨ã®æ®‹é«˜: ${discordUser.balance} ã‚³ã‚¤ãƒ³`);
        }
        
        // Update user balance
        await storage.updateDiscordUserBalance(discordUser.id, -totalPrice);
        
        // Update item stock (only if it's not infinite stock)
        if (!item.infiniteStock) {
          await storage.updateItem(item.id, { stock: item.stock - quantity });
        }
        
        // Create transaction record
        await storage.createTransaction({
          discordUserId: discordUser.id,
          itemId: item.id,
          quantity: quantity,
          totalPrice: totalPrice
        });
        
        // If there's a Discord role ID associated with the item, give role to user
        if (item.discordRoleId && interaction.guild) {
          try {
            const member = await interaction.guild.members.fetch(interaction.user.id);
            await member.roles.add(item.discordRoleId);
          } catch (roleError) {
            console.error('Error adding role:', roleError);
            // Continue with the purchase even if role assignment fails
          }
        }
        
        // é¸æŠè‚¢ãŒã‚ã‚‹å ´åˆã¯ã‚ªãƒ—ã‚·ãƒ§ãƒ³é¸æŠã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’è¿½åŠ 
        if (item.options && item.options.length > 0) {
          // é¸æŠè‚¢ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ä½œæˆ
          const selectMenu = new StringSelectMenuBuilder()
            .setCustomId('option_select_slash')
            .setPlaceholder('é¸æŠè‚¢ã‚’é¸ã‚“ã§ãã ã•ã„')
            .addOptions(
              item.options.map(option => ({
                label: option,
                value: option
              }))
            );
          
          const row = new ActionRowBuilder<any>().addComponents(selectMenu);
          
          // é¸æŠè‚¢é¸æŠç”¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
          await interaction.editReply({
            content: `${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼æ®‹é«˜: ${discordUser.balance - totalPrice} ã‚³ã‚¤ãƒ³\n\n**ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„**:`,
            components: [row]
          });
          
          // DMã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒãªã„å ´åˆã¯é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ã¿è¡¨ç¤ºã—ã¦å®Œäº†
          if (!item.content) {
            // å…¬é–‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            const publicEmbed = new EmbedBuilder()
              .setTitle('å•†å“ãŒè³¼å…¥ã•ã‚Œã¾ã—ãŸï¼')
              .setDescription(`${interaction.user.username} ãŒ ${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼`)
              .setColor('#3BA55C');
              
            await interaction.channel?.send({ embeds: [publicEmbed] });
            return;
          }
          
          try {
            // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ä½œæˆ
            const filter = (i: { user: { id: string }; }) => i.user.id === interaction.user.id;
            
            // 15ç§’å¾…æ©Ÿ
            const selected = await interaction.channel?.awaitMessageComponent({ 
              filter, 
              time: 15000 
            });
            
            if (selected && selected.isStringSelectMenu()) {
              const selectedOption = selected.values[0];
              
              // DMã‚’é€ä¿¡
              const dmChannel = await interaction.user.createDM();
              let dmContent = `**${item.name}** ã®è³¼å…¥ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼\n\n`;
              
              // é¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
              dmContent += `é¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³: **${selectedOption}**\n\n`;
              dmContent += `ã“ã“ã«è³¼å…¥ã—ãŸå•†å“ã®å†…å®¹ã‚’è¨˜è¼‰ã—ã¾ã™:\n\n${item.content}`;
              
              await dmChannel.send({
                content: dmContent
              });
              
              // é¸æŠå¾Œã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›´æ–°
              await selected.update({
                content: `${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼æ®‹é«˜: ${discordUser.balance - totalPrice} ã‚³ã‚¤ãƒ³\n\né¸æŠã•ã‚ŒãŸã‚ªãƒ—ã‚·ãƒ§ãƒ³: **${selectedOption}**\n\nğŸ“© å•†å“ã®è©³ç´°ã¯DMã‚’ã”ç¢ºèªãã ã•ã„ã€‚`,
                components: []
              });
            }
          } catch (error) {
            console.error('Option selection error:', error);
            await interaction.editReply({
              content: `${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼æ®‹é«˜: ${discordUser.balance - totalPrice} ã‚³ã‚¤ãƒ³\n\nâš ï¸ ã‚ªãƒ—ã‚·ãƒ§ãƒ³é¸æŠãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚`,
              components: []
            });
          }
        } else {
          // é¸æŠè‚¢ãŒãªã„å ´åˆã¯é€šå¸¸ã®è³¼å…¥å®Œäº†å‡¦ç†
          let successMessage = `${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼æ®‹é«˜: ${discordUser.balance - totalPrice} ã‚³ã‚¤ãƒ³`;
          
          // DMã§ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’é€ä¿¡
          if (item.content) {
            try {
              const dmChannel = await interaction.user.createDM();
              let dmContent = `**${item.name}** ã®è³¼å…¥ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼\n\n`;
              dmContent += `ã“ã“ã«è³¼å…¥ã—ãŸå•†å“ã®å†…å®¹ã‚’è¨˜è¼‰ã—ã¾ã™:\n\n${item.content}`;
              
              await dmChannel.send({
                content: dmContent
              });
              
              successMessage += `\n\nğŸ“© å•†å“ã®è©³ç´°ã¯DMã‚’ã”ç¢ºèªãã ã•ã„ã€‚`;
            } catch (error) {
              console.error("Failed to send DM:", error);
              successMessage += `\n\nâš ï¸ DMã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`;
            }
          }
          
          await interaction.editReply(successMessage);
        }
        
        // Send public message (optional)
        const publicEmbed = new EmbedBuilder()
          .setTitle('å•†å“ãŒè³¼å…¥ã•ã‚Œã¾ã—ãŸï¼')
          .setDescription(`${interaction.user.username} ãŒ ${item.name} ã‚’ ${quantity} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼`)
          .setColor('#3BA55C');
          
        await interaction.channel?.send({ embeds: [publicEmbed] });
      } catch (error) {
        console.error('Error in buy command:', error);
        await interaction.editReply('è³¼å…¥å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Balance command - check user's balance
  const balanceCommand = {
    data: new SlashCommandBuilder()
      .setName('vending_balance')
      .setDescription('æ®‹é«˜ã‚’ç¢ºèªã—ã¾ã™'),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      try {
        // Get the user
        const discordUser = await storage.getDiscordUserByDiscordId(interaction.user.id);
        if (!discordUser) {
          return await interaction.editReply('ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        // Get bot settings or use defaults
        const guildSettings = await storage.getBotSettings(interaction.guildId || '');
        const currencyName = guildSettings?.currencyName || 'ã‚³ã‚¤ãƒ³';
        
        // Send balance message
        await interaction.editReply(`ç¾åœ¨ã®æ®‹é«˜: ${discordUser.balance} ${currencyName}`);
      } catch (error) {
        console.error('Error in balance command:', error);
        await interaction.editReply('æ®‹é«˜ã®ç¢ºèªä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Admin commands - for managing items
  
  // Add item command
  const addCommand = {
    data: new SlashCommandBuilder()
      .setName('vending_add')
      .setDescription('æ–°ã—ã„å•†å“ã‚’è¿½åŠ ã—ã¾ã™ (ç®¡ç†è€…ã®ã¿)')
      .addStringOption(option => 
        option.setName('name')
          .setDescription('å•†å“å')
          .setRequired(true))
      .addIntegerOption(option => 
        option.setName('price')
          .setDescription('ä¾¡æ ¼')
          .setRequired(true))
      .addStringOption(option => 
        option.setName('description')
          .setDescription('å•†å“ã®èª¬æ˜')
          .setRequired(true))
      .addIntegerOption(option => 
        option.setName('stock')
          .setDescription('åœ¨åº«æ•°')
          .setRequired(false))
      .addStringOption(option => 
        option.setName('role_id')
          .setDescription('ä»˜ä¸ã™ã‚‹ãƒ­ãƒ¼ãƒ«ID (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)')
          .setRequired(false)),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      // Check if user has admin permissions
      if (!interaction.memberPermissions?.has('Administrator')) {
        return await interaction.editReply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
      }
      
      try {
        const name = interaction.options.getString('name', true);
        const price = interaction.options.getInteger('price', true);
        const description = interaction.options.getString('description', true);
        const stock = interaction.options.getInteger('stock') || 0;
        const roleId = interaction.options.getString('role_id') || null;
        
        // Create the item
        const item = await storage.createItem({
          name,
          description,
          price,
          stock,
          isActive: true,
          discordRoleId: roleId
        });
        
        await interaction.editReply(`å•†å“ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼š${item.name} (ID: ${item.id}, ä¾¡æ ¼: ${item.price} ã‚³ã‚¤ãƒ³)`);
      } catch (error) {
        console.error('Error in add command:', error);
        await interaction.editReply('å•†å“ã®è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Remove item command
  const removeCommand = {
    data: new SlashCommandBuilder()
      .setName('vending_remove')
      .setDescription('å•†å“ã‚’å‰Šé™¤ã—ã¾ã™ (ç®¡ç†è€…ã®ã¿)')
      .addIntegerOption(option => 
        option.setName('item_id')
          .setDescription('å‰Šé™¤ã™ã‚‹å•†å“ã®ID')
          .setRequired(true)),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      // Check if user has admin permissions
      if (!interaction.memberPermissions?.has('Administrator')) {
        return await interaction.editReply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
      }
      
      try {
        const itemId = interaction.options.getInteger('item_id', true);
        
        // Get the item first to check if it exists
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.editReply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        // Delete the item
        await storage.deleteItem(itemId);
        
        await interaction.editReply(`å•†å“ã‚’å‰Šé™¤ã—ã¾ã—ãŸï¼š${item.name} (ID: ${item.id})`);
      } catch (error) {
        console.error('Error in remove command:', error);
        await interaction.editReply('å•†å“ã®å‰Šé™¤ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Update price command
  const priceCommand = {
    data: new SlashCommandBuilder()
      .setName('vending_price')
      .setDescription('å•†å“ã®ä¾¡æ ¼ã‚’å¤‰æ›´ã—ã¾ã™ (ç®¡ç†è€…ã®ã¿)')
      .addIntegerOption(option => 
        option.setName('item_id')
          .setDescription('ä¾¡æ ¼ã‚’å¤‰æ›´ã™ã‚‹å•†å“ã®ID')
          .setRequired(true))
      .addIntegerOption(option => 
        option.setName('new_price')
          .setDescription('æ–°ã—ã„ä¾¡æ ¼')
          .setRequired(true)),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      // Check if user has admin permissions
      if (!interaction.memberPermissions?.has('Administrator')) {
        return await interaction.editReply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
      }
      
      try {
        const itemId = interaction.options.getInteger('item_id', true);
        const newPrice = interaction.options.getInteger('new_price', true);
        
        if (newPrice < 0) {
          return await interaction.editReply('ä¾¡æ ¼ã¯0ä»¥ä¸Šã®å€¤ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
        }
        
        // Get the item first to check if it exists
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.editReply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        // Update the item price
        const updatedItem = await storage.updateItem(itemId, { price: newPrice });
        
        await interaction.editReply(`å•†å“ã®ä¾¡æ ¼ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼š${updatedItem?.name} (æ–°ä¾¡æ ¼: ${newPrice} ã‚³ã‚¤ãƒ³)`);
      } catch (error) {
        console.error('Error in price command:', error);
        await interaction.editReply('ä¾¡æ ¼ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Update stock command
  const stockCommand = {
    data: new SlashCommandBuilder()
      .setName('vending_stock')
      .setDescription('å•†å“ã®åœ¨åº«æ•°ã‚’è¨­å®šã—ã¾ã™ (ç®¡ç†è€…ã®ã¿)')
      .addIntegerOption(option => 
        option.setName('item_id')
          .setDescription('åœ¨åº«ã‚’å¤‰æ›´ã™ã‚‹å•†å“ã®ID')
          .setRequired(true))
      .addIntegerOption(option => 
        option.setName('quantity')
          .setDescription('æ–°ã—ã„åœ¨åº«æ•°')
          .setRequired(true)),
    async execute(interaction: CommandInteraction, storage: IStorage) {
      await interaction.deferReply({ ephemeral: true });
      
      // Check if user has admin permissions
      if (!interaction.memberPermissions?.has('Administrator')) {
        return await interaction.editReply('ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯ç®¡ç†è€…ã®ã¿ä½¿ç”¨ã§ãã¾ã™ã€‚');
      }
      
      try {
        const itemId = interaction.options.getInteger('item_id', true);
        const quantity = interaction.options.getInteger('quantity', true);
        
        if (quantity < 0) {
          return await interaction.editReply('åœ¨åº«æ•°ã¯0ä»¥ä¸Šã®å€¤ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚');
        }
        
        // Get the item first to check if it exists
        const item = await storage.getItem(itemId);
        if (!item) {
          return await interaction.editReply('æŒ‡å®šã•ã‚ŒãŸå•†å“ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚');
        }
        
        // Update the item stock
        const updatedItem = await storage.updateItem(itemId, { stock: quantity });
        
        await interaction.editReply(`å•†å“ã®åœ¨åº«æ•°ã‚’å¤‰æ›´ã—ã¾ã—ãŸï¼š${updatedItem?.name} (æ–°åœ¨åº«æ•°: ${quantity})`);
      } catch (error) {
        console.error('Error in stock command:', error);
        await interaction.editReply('åœ¨åº«æ•°ã®å¤‰æ›´ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
      }
    },
  };
  
  // Register all commands with the client
  const commands = [
    showCommand,
    buyCommand,
    balanceCommand,
    addCommand,
    removeCommand,
    priceCommand,
    stockCommand,
    addCoinsCommand
  ];
  
  // Add each command to the client.commands collection
  for (const command of commands) {
    client.commands.set(command.data.name, command);
  }
  
  try {
    // APIã«ã‚³ãƒãƒ³ãƒ‰ã‚’ç™»éŒ²
    console.log('Started refreshing application (/) commands.');
    
    const commandsData = commands.map(command => command.data.toJSON());
    
    // RESTãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦Discord APIã¨é€šä¿¡
    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_BOT_TOKEN || '');
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦ç™»éŒ²ï¼ˆã™ã¹ã¦ã®ã‚µãƒ¼ãƒãƒ¼ã§åˆ©ç”¨å¯èƒ½ï¼‰
    await rest.put(
      Routes.applicationCommands(client.user!.id),
      { body: commandsData },
    );
    
    console.log(`Successfully registered ${commands.length} application commands globally.`);
  } catch (error) {
    console.error('Error registering application commands:', error);
  }
  
  console.log(`Registered ${commands.length} vending machine commands`);
}
